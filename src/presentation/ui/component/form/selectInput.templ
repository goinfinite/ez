package componentForm

templ SelectInput(
	id, label, bindValuePath string, options []string, denseMode bool,
) {
	<!-- SelectInput -->
	<div class="relative w-full">
		<select
			id={ id }
			name={ id }
			x-model:value={ bindValuePath }
			placeholder={ label }
			if denseMode {
				class="bg-ez-300 hover:border-ez-100 border-ez-200 autofill:bg-ez-300 focus:border-ez-50 h-7.5 peer relative w-full appearance-none rounded-md border px-1.5 text-[13px] leading-normal text-neutral-100 placeholder-transparent outline-none transition-all"
			} else {
				class="bg-ez-300 hover:border-ez-100 border-ez-200 autofill:bg-ez-300 focus:border-ez-50 peer relative h-10 w-full appearance-none rounded-md border px-3 text-sm text-neutral-100 placeholder-transparent outline-none transition-all"
			}
		>
			<option class="bg-ez-500 checked:bg-infinite-500 bg-opacity-90" value></option>
			for _, option := range options {
				<option class="bg-ez-500 checked:bg-infinite-500 bg-opacity-90" value={ option }>{ option }</option>
			}
		</select>
		if label != "" {
			<label
				for={ id }
				class="from-ez-300 via-ez-300 absolute -top-2 left-1.5 z-[1] cursor-text bg-gradient-to-t via-55% to-transparent to-55% px-1.5 text-xs font-bold text-neutral-50 text-opacity-80 transition-all before:absolute before:left-0 before:top-0 before:z-[-1] before:block before:h-full before:w-full before:bg-white before:transition-all peer-placeholder-shown:top-2.5 peer-placeholder-shown:text-sm peer-placeholder-shown:font-normal peer-autofill:-top-2 peer-hover:text-opacity-90 peer-focus:-top-2 peer-focus:cursor-default peer-focus:text-opacity-100"
			>
				{ label }
			</label>
		}
		<i class="ph-bold ph-caret-down pointer-events-none absolute right-2.5 top-3.5 text-sm"></i>
	</div>
}

type SelectLabelValuePair struct {
	Label string
	Value string
}

templ SelectInputWithLabelValuePair(
	id, label, bindValuePath string,
	options []SelectLabelValuePair,
	shouldIncludeBlankOption bool,
) {
	<!-- SelectInputWithLabelValuePair -->
	<div class="relative w-full">
		<select
			id={ id }
			name={ id }
			if bindValuePath != "" {
				x-model:value={ bindValuePath }
			}
			placeholder={ label }
			class="bg-ez-300 hover:border-ez-100 border-ez-200 autofill:bg-ez-300 focus:border-ez-50 peer relative h-10 w-full appearance-none rounded-md border px-3 text-sm text-neutral-100 placeholder-transparent outline-none transition-all"
		>
			if shouldIncludeBlankOption {
				<option class="bg-ez-500 checked:bg-infinite-500 bg-opacity-90" value="">--</option>
			}
			for _, option := range options {
				<option
					class="bg-ez-500 checked:bg-infinite-500 bg-opacity-90"
					value={ option.Value }
				>
					{ option.Label }
				</option>
			}
		</select>
		if label != "" {
			<label
				for={ id }
				class="from-ez-300 via-ez-300 absolute -top-2 left-1.5 z-[1] cursor-text bg-gradient-to-t via-55% to-transparent to-55% px-1.5 text-xs font-bold text-neutral-50 text-opacity-80 transition-all before:absolute before:left-0 before:top-0 before:z-[-1] before:block before:h-full before:w-full before:bg-white before:transition-all peer-placeholder-shown:top-2.5 peer-placeholder-shown:text-sm peer-placeholder-shown:font-normal peer-autofill:-top-2 peer-hover:text-opacity-90 peer-focus:-top-2 peer-focus:cursor-default peer-focus:text-opacity-100"
			>
				{ label }
			</label>
		}
		<i class="ph-bold ph-caret-down pointer-events-none absolute right-2.5 top-3.5 text-sm"></i>
	</div>
}

script SearchableSelectInputLocalState(id string) {
	document.addEventListener('alpine:init', () => {
		Alpine.data('searchableSelect', () => ({
			searchableItems: JSON.parse(
				document.getElementById(id + 'SearchableItems').textContent
			),
			showDropdown: false,
			userInput: '',
			selectedItem: null,
			resetState() {
				this.userInput = '';
				this.selectedItem = null;
				this.closeDropdown();
			},
			openDropdown() { 
				this.showDropdown = true; 
			},
			closeDropdown() {
				this.showDropdown = false;
			},
			setSelectedItem(itemValue) {
				this.selectedItem = this.filteredItems.get(itemValue);
				this.userInput = this.selectedItem.label;
				this.showDropdown = false;
			},
			get filteredItems() {
				const filteredItemsMap = new Map();
				this.searchableItems.forEach(item => {
					if (this.userInput === '') {
						filteredItemsMap.set(item.value, item);
						return;
					}

					const searchableText = item.searchableText || item.label;
					if (!searchableText.includes(this.userInput)) {
						return;
					}
					filteredItemsMap.set(item.value, item);
				});

				return filteredItemsMap;
			},
		}));
	});
}

type SearchableSelectItem struct {
	Label          string           `json:"label"`
	Value          string           `json:"value"`
	SearchableText *string          `json:"searchableText"`
	HtmlLabel      *templ.Component `json:"-"`
}

func readSearchableSelectItemLabel(item SearchableSelectItem) templ.Component {
	if item.HtmlLabel != nil {
		return *item.HtmlLabel
	}
	return templ.Raw(item.Label)
}

templ SearchableSelectInput(
	id, label, bindValuePath string,
	searchableItems []SearchableSelectItem,
) {
	<!-- SearchableSelectInput JavaScript -->
	@templ.JSONScript(id+"SearchableItems", searchableItems)
	@SearchableSelectInputLocalState(id)
	<!-- SearchableSelectInput HTML -->
	<div
		x-data="searchableSelect"
		class="relative flex flex-col items-center"
	>
		<input type="hidden" id={ id } name={ id } x-model:value={ bindValuePath }/>
		<div
			@click.away="closeDropdown()"
			class="bg-ez-300 hover:border-ez-100 border-ez-200 autofill:bg-ez-300 focus:border-ez-50 relative flex h-10 w-full appearance-none rounded-md border px-3 text-sm text-neutral-100 outline-none transition-all"
		>
			<input
				id={ id + "SelectInput" }
				placeholder={ label }
				x-model="userInput"
				@mousedown="openDropdown()"
				class="peer w-full appearance-none bg-transparent placeholder-transparent outline-none"
			/>
			if label != "" {
				<label
					for={ id + "SelectInput" }
					class="from-ez-300 via-ez-300 absolute -top-2 left-1.5 z-[1] cursor-text bg-gradient-to-t via-55% to-transparent to-55% px-1.5 text-xs font-bold text-neutral-50 text-opacity-80 transition-all before:absolute before:left-0 before:top-0 before:z-[-1] before:block before:h-full before:w-full before:bg-white before:transition-all peer-placeholder-shown:top-2.5 peer-placeholder-shown:text-sm peer-placeholder-shown:font-normal peer-autofill:-top-2 peer-hover:text-opacity-90 peer-focus:-top-2 peer-focus:cursor-default peer-focus:text-opacity-100"
				>
					{ label }
				</label>
			}
			<i
				x-show="userInput !== ''"
				@click.prevent="resetState()"
				class="ph-bold ph-x-circle right-7.5 absolute top-2.5 cursor-pointer text-xl text-neutral-200 hover:text-neutral-50"
			></i>
			<i class="ph-bold ph-caret-down pointer-events-none absolute right-2.5 top-3.5 text-sm"></i>
		</div>
		<div
			x-show="showDropdown"
			class="bg-ez-300 absolute top-10 z-40 max-h-64 w-full overflow-y-auto rounded-b-md drop-shadow-xl"
		>
			<div class="[&>*:nth-child(even)]:bg-ez-400 flex w-full flex-col">
				for _, searchableItem := range searchableItems {
					<div
						x-show={ "filteredItems.has('" + searchableItem.Value + "')" }
						class="hover:bg-ez-700 cursor-pointer p-2"
						@click={ "setSelectedItem('" + searchableItem.Value + "'); " + bindValuePath + " = '" + searchableItem.Value + "'" }
					>
						@readSearchableSelectItemLabel(searchableItem)
					</div>
				}
			</div>
		</div>
	</div>
}
